 بخش اول)تشخیص زیرمسائل و الگوها
 ۱. زیرمسئله: مدیریت حالت‌ها
 
- NEW 
- ASSIGNED 
- IN_PROGRESS 
- RESOLVED 
- CLOSED 

در کد فعلی، این حالت‌ها به صورت رشته‌ای مدیریت شده و رفتار هر حالت با استفاده از زنجیره‌ای از دستورات if-else پیاده‌سازی شده است .

الگوی انتخابی:

الگوی State برای این مسئله مناسب است زیرا رفتار سیستم به شدت وابسته به حالت فعلی شیء است و هر حالت منطق پردازش خاص خود را دارد.

دلیل اتخاب :

۱. حذف شرط‌های پیچیده: جایگزینی if-else های تودرتو با اشیاء حالت مستقل.

۲. انعطاف‌پذیری: اضافه کردن حالت جدید بدون تغییر کد موجود.

۳. تک‌مسئولیتی: هر کلاس حالت فقط مسئول رفتار آن حالت خاص است.

۴. قابلیت تست: هر حالت به صورت مجزا قابل تست است.

روش اعمال:

۱. ایجاد اینترفیس TicketState با متد handle(TicketContext context).

۲. پیاده‌سازی کلاس‌های حالت:


- NewState: مسئول ایجاد تیکت و دریافت از کانال

- AssignedState: مسئول ارجاع تیکت به واحد مربوطه

- InProgressState: مسئول پردازش و پاسخ‌دهی

- ResolvedState: مسئول اعلام حل شدن تیکت

- ClosedState: مسئول بستن تیکت


 ۳. کلاس Ticket دارای فیلد currentState از نوع TicketState.
 
۴. تغییر حالت از طریق متد setState(TicketState newState).


۲. زیرمسئله: دریافت درخواست از کانال‌های ورودی مختلف


سیستم باید بتواند درخواست‌ها را از کانال‌های مختلفی مانند WEB و EMAIL دریافت کند. در کد فعلی، منطق دریافت هر کانال در شرط‌های if-else پیاده‌سازی شده است.

الگوی انتخابی: 

الگوی Strategy مناسب است زیرا هر کانال الگوریتم دریافت خاص خود را دارد و این الگوریتم‌ها ممکن است در آینده تغییر یا گسترش یابند.

دلیل انتخاب :

۱. جداسازی مسئولیت‌ها: تفکیک منطق دریافت از منطق اصلی پردازش.

۲. قابلیت گسترش: افزودن کانال جدید بدون تغییر کد موجود.

۳. قابلیت تعویض: امکان تغییر استراتژی دریافت در زمان اجرا.

۴. پایستگی کم: کاهش وابستگی بین کلاس‌ها.

روش اعمال :

۱. ایجاد اینترفیس ChannelStrategy با متد receive(): String

۲. پیاده‌سازی کلاس‌های استراتژی:

- WebChannelStrategy: منطق دریافت از وب

- EmailChannelStrategy: منطق دریافت از ایمیل

- SMSChannelStrategy (برای آینده): منطق دریافت از پیامک

۳. کلاس Ticket دارای فیلد channelStrategy: ChannelStrategy

۴. استراتژی مناسب در زمان ایجاد تیکت تزریق می‌شود.


۳. زیرمسئله: پردازش انواع مختلف تیکت
 
 تیکت‌ها انواع مختلفی دارند (مانند BUG و سایر انواع). هر نوع تیکت:

-به واحد سازمانی متفاوتی ارجاع داده می‌شود.

-پاسخ متفاوتی دریافت می‌کند.

-ممکن است فرآیند پردازش متفاوتی داشته باشد.
 
الگوی انتخابی:

الگوی Strategy مجدداً مناسب است زیرا هر نوع تیکت الگوریتم پردازش خاص خود را دارد.

دلیل انتخاب : 

۱. تنوع رفتار: هر نوع تیکت رفتار کاملاً متفاوتی دارد.

۲. انعطاف‌پذیری: افزودن نوع جدید تیکت بدون تغییر کد موجود.

۳. حفظ اصول SOLID: رعایت اصل Open/Closed Principle

۴. قابلیت استفاده مجدد: استراتژی‌ها در بخش‌های مختلف قابل استفاده هستند.

روش اعمال :

۱. ایجاد اینترفیس TicketTypeStrategy با متدهای:

- assignDepartment(): String

- generateResponse(): String

- getPriority(): int
۲. پیاده‌سازی کلاس‌های استراتژی:

- BugTicketStrategy: ارجاع به واحد مهندسی، پاسخ فنی

- SupportTicketStrategy: ارجاع به پشتیبانی، پاسخ عمومی

- FeatureRequestStrategy: ارجاع به واحد محصول، پاسخ تأیید/رد

  
۳. کلاس Ticket دارای فیلد typeStrategy: TicketTypeStrategy



