# بخش ۱) تشخیص الگوها و زیرمسئله‌ها

## ۱. مدیریت چرخه عمر و گذار وضعیت  

•زیرمسئله: متغیر state به صورت String تعریف شده و در هر مرحله از متد handle مقدار آن تغییر می‌کند. تمام منطق‌های مربوط به وضعیت‌های NEW, ASSIGNED, IN_PROGRESS و غیره در یک متد متمرکز شده‌اند که نگهداری آن را غیرممکن می‌کند.

•	الگوی پیشنهادی: State Pattern

•	دلیل انتخاب: این الگو به ما اجازه می‌دهد هر وضعیت را به یک کلاس مستقل تبدیل کنیم. به این ترتیب، انتقال از یک وضعیت به وضعیت بعدی (مثلاً از ASSIGNED به IN_PROGRESS) به جای تغییر یک متغیر رشته‌ای، با تغییر شیء وضعیت انجام می‌شود.

•	روش اعمال: یک اینترفیس TicketState تعریف می‌کنیم. کلاس‌هایی مانند NewState و AssignedState را می‌سازیم. هر کلاس مسئول چاپ پیام مربوط به خود و تغییر وضعیتِ تیکت به مرحله بعدی است.

## ۲. تنوع در منطق پاسخ‌دهی   

• زیرمسئله: در کد مشاهده می‌شود که بر اساس type (مثلاً BUG یا غیره)، سیستم تصمیم می‌گیرد که پاسخ متفاوتی ارسال کند (bug response در مقابل generic response). در حال حاضر این منطق با دستور if سخت‌کد (Hard-coded) شده است.

•	الگوی پیشنهادی: Strategy Pattern

•	دلیل انتخاب: اگر بخواهیم در آینده نوع جدیدی از پاسخ (مثلاً پاسخ برای تیکت‌های مالی) اضافه کنیم، نباید متد اصلی را دستکاری کنیم. الگوی استراتژی به ما اجازه می‌دهد الگوریتم پاسخ‌دهی را به عنوان یک "قابلیت" به تیکت تزریق کنیم.

•	روش اعمال: یک اینترفیس ResponseStrategy با متد send() ایجاد می‌کنیم. کلاس‌های BugResponse و GenericResponse این اینترفیس را پیاده‌سازی می‌کنند.

## ۳. ساختاردهی به ایجاد تیکت  

•	شرح زیرمسئله: منطق بررسی کانال ورودی (WEB یا EMAIL) در ابتدای متد قرار دارد. این یعنی سیستم مستقیماً درگیر جزئیات ساخت و شناسایی اولیه تیکت شده است.

•	الگوی پیشنهادی: Factory Method

•	دلیل انتخاب: برای جداسازی منطق "ساخت و پیکربندی" از منطق "پردازش"، به یک کارخانه نیاز داریم تا بر اساس پارامترهای ورودی، شیء تیکت را با ویژگی‌های درست (مثل نوع استراتژی یا وضعیت اولیه) ایجاد کند.

•	روش اعمال: کلاس TicketFactory را ایجاد می‌کنیم که متدی برای تولید تیکت بر اساس کانال ورودی دارد و اشیاء لازم را نمونه‌سازی می‌کند.

# بخش دوم) ترسیم Diagram Class 

<img width="1838" height="1074" alt="class-diagram" src="https://github.com/user-attachments/assets/d99ddf3c-3e60-4bda-8cd9-1be43c3066ba" />


# بخش سوم) اعمال الگو
در این مرحله، کد اولیه کلاس TicketService که شامل دستورات شرطی (if-else) متعدد و مدیریت دستی وضعیت‌ها بود، بر اساس الگوهای طراحی بازآرایی شد:

۱. پیاده‌سازی الگوی State 

به جای استفاده از یک متغیر رشته‌ای (String state) برای ذخیره وضعیت، یک سلسله مراتب از کلاس‌ها ایجاد شد:

اینترفیس TicketState: رفتارهای مشترک تمام وضعیت‌ها (متد handle) را تعریف می‌کند.

کلاس‌های Concrete State: برای هر وضعیت (NewState, AssignedState, ...)، یک کلاس مجزا ساخته شد. هر کلاس وظیفه دارد پیام مربوط به آن مرحله را چاپ کرده و تیکت را به وضعیت بعدی منتقل کند. این کار باعث شد منطقِ "تغییر وضعیت" از کلاس اصلی خارج شود.

۲. پیاده‌سازی الگوی Strategy

برای مدیریت تنوع در "کانال‌های ورودی" و "نوع پاسخ‌دهی"، از استراتژی استفاده کردیم:

استراتژی کانال: متد()receiveRequest در کلاس تیکت، حالا به جای چک کردن if(channel == WEB)، مستقیماً متد استراتژی تزریق شده را صدا می‌زند.

استراتژی نوع تیکت: رفتارهای متفاوتی که برای BUG و SUPPORT در کد اولیه وجود داشت، به کلاس‌های BugStrategy و SupportStrategy منتقل شد. با این کار، اگر در آینده نوع تیکت جدیدی اضافه شود، نیازی به تغییر کدهای قبلی نیست.

۳. پیاده‌سازی کارخانه (Factory Method)
برای ساده‌سازی فرآیند ایجاد شیء تیکت، کلاس TicketFactory ایجاد شد.

این کلاس وظیفه دارد بر اساس رشته‌های ورودی (WEB/EMAIL و BUG/QUESTION)، نمونه‌های صحیح از استراتژی‌ها را بسازد و به شیء Ticket تحویل دهد. این کار باعث می‌شود کلاینت (کلاس Main) درگیر جزئیاتِ پیچیده ساخت اشیاء نشود.

۴. متمرکز کردن فرآیند در کلاس Context
کلاس Ticket به عنوان هماهنگ‌کننده عمل می‌کند. متد()process در این کلاس، با استفاده از یک حلقه ساده، تیکت را در چرخه وضعیت‌ها حرکت می‌دهد تا به وضعیت نهایی (Closed) برسد.  

# بخش ۴) تحلیل شی‌گرا

با اعمال الگوهای State و Strategy، وابستگی‌های مستقیم و شرط‌های تودرتو حذف شده و سیستم از نظر SOLID (به‌ویژه OCP و SRP) کاملاً منعطف و تفکیک‌شده عمل می‌کند. رعایت PLK باعث شده تا کلاینت بدون درگیری با پیچیدگی‌های داخلی، فقط با لایه سرویس تعامل کند و از سوی دیگر، استفاده از CRP (ترکیب به جای ارث‌بری) در ساختار تیکت، امکان تغییر رفتار و وضعیت را در زمان اجرا فراهم کرده است. در مجموع، سیستم از یک کد "سخت و شکننده" به یک معماری "ماژولار و تست‌پذیر" تبدیل شده که هزینه توسعه را به شدت کاهش می‌دهد..

---
